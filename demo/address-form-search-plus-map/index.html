<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Delivery Address: Autocomplete + Draggable Pin</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Geoapify theme for autocomplete -->
  <link id="geocoder-theme" rel="stylesheet" type="text/css" href="../../styles/minimal.css" />

  <link rel="stylesheet" href="./index.css" />
</head>

<body>
  <div class="theme-selector">
    <span class="theme-label">Theme:</span>
    <select id="theme-selector" onchange="setTheme(this.value)">
      <option value="minimal">Light</option>
      <option value="minimal-dark">Dark</option>
      <option value="round-borders">Light (Round)</option>
      <option value="round-borders-dark">Dark (Round)</option>
    </select>
  </div>
  <div class="dev-visibility">
    <input type="checkbox" id="dev-toggle" checked />
    <label for="dev-toggle">Show developer info</label>
  </div>

  <div class="container">
    <div class="sample-header">
      <h1>Delivery Address: Autocomplete + Draggable Pin</h1>
      <p class="helper-text">Start with type‑ahead search, then adjust a pin to the exact entrance. Reverse geocoding keeps the address in sync and the app saves the final coordinates plus the confirmed address. Includes IP bias and developer-friendly diagnostics.</p>
    </div>
    <!-- IP Geolocation (top-level developer info) -->
    <div class="dev-panel" id="dev-ip-top">
      <h4>IP Geolocation</h4>
      <div class="kv" id="dev-ip"></div>
    </div>

    <!-- 1. Search address -->
    <div class="section-block" aria-labelledby="sec1-title">
      <div class="section-title">
        <span class="section-num" aria-hidden="true">1</span>
        <span id="sec1-title" class="section-heading">Search address</span>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <div id="autocomplete" class="autocomplete-container" style="flex:1;"></div>
        <button id="geo-btn" type="button" title="Use my location">Use my location</button>
      </div>
      <div class="helper-text">Search to start or use your current location. We’ll center the map; you can fine‑tune the
        pin below.</div>

      <!-- Panel 1 reverse geocoding (shown after "Use my location") -->
      <div class="dev-panel" id="dev-rev1-panel" hidden>
        <h4>Reverse geocode (my location)</h4>
        <div class="kv" id="dev-rev1"></div>
        <pre class="code" id="dev-rev1-json"></pre>
      </div>
    </div>

    <!-- 2. Pin adjust -->
    <div class="section-block" aria-labelledby="sec2-title">
      <div class="section-title">
        <span class="section-num" aria-hidden="true">2</span>
        <span id="sec2-title" class="section-heading">Adjust pin</span>
      </div>
      <div class="helper-text">Drag the pin to your exact entrance. We always save the pin’s coordinates. If the pin is
        far from the selected address, we’ll use the pin coordinates.</div>

      <div id="map"></div>

      <div class="dev-panel" id="dev-rev2-panel" hidden>
        <h4>Reverse geocode (pin)</h4>
        <div class="kv" id="dev-rev2"></div>
        <pre class="code" id="dev-rev2-json"></pre>
      </div>
    </div>

    <!-- 3. Confirm location -->
    <div class="section-block" aria-labelledby="sec3-title">
      <div class="section-title">
        <span class="section-num" aria-hidden="true">3</span>
        <span id="sec3-title" class="section-heading">Confirm location</span>
      </div>
      <div id="confirm-message" class="message" aria-live="polite"></div>
      <div class="actions"><button id="confirm-btn" disabled>Confirm location</button></div>

      <div class="dev-panel" id="dev-summary-panel" hidden>
        <h4>Developer summary</h4>
        <div class="kv" id="dev-summary"></div>
        <pre class="code" id="dev-summary-json"></pre>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Geoapify Autocomplete JS -->
  <script src="../../dist/index.min.js"></script>

  <script>
    /* WARNING: This API key is provided for DEMO purposes only.
       Please sign up at https://www.geoapify.com and generate your own API key.
       The demo key may be rotated or blocked at any moment without notice.
    */
    const myAPIKey = "52f7bd50de994836b609fbfc6f082700";

    // Theme support
    function setTheme(themeName) {
      const themeLink = document.getElementById('geocoder-theme');
      themeLink.href = `../../styles/${themeName}.css`;
      document.body.className = document.body.className.replace(/theme-\w+/g, '');
      document.body.classList.add(`theme-${themeName}`);
      localStorage.setItem('geocoder-theme', themeName);
    }
    window.addEventListener('load', () => {
      const savedTheme = localStorage.getItem('geocoder-theme') || 'minimal';
      document.getElementById('theme-selector').value = savedTheme;
      setTheme(savedTheme);
    });

    // Elements
    const geoBtn = document.getElementById('geo-btn');
    const confirmBtn = document.getElementById('confirm-btn');
    const confirmMessage = document.getElementById('confirm-message');
    const devIpEl = document.getElementById('dev-ip');
    const devRev1GeoPanel = document.getElementById('dev-rev1-panel');
    const devRev1GeoEl = document.getElementById('dev-rev1');
    const devRev1GeoJsonEl = document.getElementById('dev-rev1-json');

    const devRev2GeoPanel = document.getElementById('dev-rev2-panel');
    const devRev2PinEl = document.getElementById('dev-rev2');
    const devRev2PinJsonEl = document.getElementById('dev-rev2-json');
    const devSummaryPanel = document.getElementById('dev-summary-panel');
    const devSummaryEl = document.getElementById('dev-summary');
    const devSummaryJsonEl = document.getElementById('dev-summary-json');


    // search results
    let ipGeolocation = null;
    let geolocation = null;
    let lastRevFromGeo = null;
    let lastRevFromDrag = null;
    let lastSearch = null;

    let lastAddress = null;
    let lastLocation = null;

    const MAX_LOCATION_TO_ADDRESS_ERROR = 50; // 50 meters

    // Map + marker
    const map = L.map('map', { zoomControl: true }).setView([20, 0], 2);
    const isRetina = L.Browser.retina;
    const tileUrl = isRetina
      ? `https://maps.geoapify.com/v1/tile/osm-bright/{z}/{x}/{y}@2x.png?apiKey=${myAPIKey}`
      : `https://maps.geoapify.com/v1/tile/osm-bright/{z}/{x}/{y}.png?apiKey=${myAPIKey}`;
    L.tileLayer(tileUrl, {
      attribution: 'Powered by <a href="https://www.geoapify.com/" target="_blank">Geoapify</a> | <a href="https://openmaptiles.org/" rel="nofollow" target="_blank">© OpenMapTiles</a> <a href="https://www.openstreetmap.org/copyright" rel="nofollow" target="_blank">© OpenStreetMap</a> contributors'
    }).addTo(map);

    const markerIcon = L.icon({
      iconUrl: `https://api.geoapify.com/v1/icon/?type=awesome&color=%232ea2ff&size=large&scaleFactor=2&apiKey=${myAPIKey}`,
      iconSize: [38, 56], iconAnchor: [19, 51], popupAnchor: [0, -60]
    });
    let marker = null;


    // Initialize autocomplete with optional bias later
    const ac = new autocomplete.GeocoderAutocomplete(document.getElementById('autocomplete'), myAPIKey, {
      skipIcons: true,
      allowNonVerifiedStreet: true,
      allowNonVerifiedHouseNumber: true
    });

    // IP geolocation for bias and initial view
    fetch(`https://api.geoapify.com/v1/ipinfo?apiKey=${myAPIKey}`)
      .then(r => r.json())
      .then(ip => {
        const loc = ip.location && ip.location.latitude && ip.location.longitude ? { lat: ip.location.latitude, lon: ip.location.longitude } : null;
        const cc = ip.country && ip.country.iso_code ? ip.country.iso_code : null;
        if (loc) {
          map.setView([loc.lat, loc.lon], 12);
          // Bias autocomplete by proximity
          if (ac.addBiasByProximity) { ac.addBiasByProximity({ lat: loc.lat, lon: loc.lon }); }
        }
        devIpEl.innerHTML = [
          cc ? `<strong>Country:</strong> ${cc}` : '',
          loc ? `<strong>Center:</strong> ${loc.lat.toFixed(5)}, ${loc.lon.toFixed(5)}` : '',
        ].filter(Boolean).join(' | ');

        ipGeolocation = ip;
      })
      .catch(() => {
        devIpEl.textContent = 'IP geolocation unavailable.';
      });

    // Handle selection
    ac.on('select', (res) => {
      if (!res || !res.properties) return;
      const p = res.properties;
      lastSearch = p;
      lastAddress = p;
      lastLocation = {
        lat: p.lat,
        lon: p.lon
      }

      // Add/move marker
      const latlng = [p.lat, p.lon];
      if (!marker) {
        marker = L.marker(latlng, { icon: markerIcon, draggable: true }).addTo(map);
        marker.on('dragend', onMarkerDragEnd);
      } else {
        marker.setLatLng(latlng);
      }
      map.setView(latlng, Math.max(map.getZoom(), 16));
      updateConfirmState();
    });

    // Browser geolocation + reverse geocoding
    geoBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      geoBtn.disabled = true;
      navigator.geolocation.getCurrentPosition(pos => {

        geolocation = pos;

        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        const latlng = [lat, lon];
        if (!marker) {
          marker = L.marker(latlng, { icon: markerIcon, draggable: true }).addTo(map);
          marker.on('dragend', onMarkerDragEnd);
        } else {
          marker.setLatLng(latlng);
        }
        map.setView(latlng, Math.max(map.getZoom(), 16));

        lastLocation = {
          lat: lat,
          lon: lon
        }

        reverseGeocode(lat, lon, (rev) => {
          const pr = rev.properties || {};
          if (pr.formatted && ac) { ac.setValue(pr.formatted); }
          lastAddress = pr;
          devRev1GeoPanel.hidden = false;
          const urlMasked = `https://api.geoapify.com/v1/geocode/reverse?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&apiKey=YOUR_API_KEY`;
          devRev1GeoEl.innerHTML = `<strong>URL:</strong> ${urlMasked} | <strong>Formatted:</strong> ${pr.formatted || '—'}`;
          const propsSnippet = JSON.stringify(pr, null, 2);
          devRev1GeoJsonEl.textContent = propsSnippet.length > 4000 ? propsSnippet.slice(0, 4000) + '\n…' : propsSnippet;
          lastRevFromGeo = pr;
          updateConfirmState();
        }, 'geo');
        geoBtn.disabled = false;
      }, err => {
        alert('Unable to retrieve your location.');
        geoBtn.disabled = false;
      }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
    });

    function onMarkerDragEnd() {
      if (!marker) return;
      const { lat, lng } = marker.getLatLng();
      confirmMessage.textContent = 'Pin updated. Please confirm the location.';

      lastLocation = {
        lat: lat,
        lon: lng
      }

      reverseGeocode(lat, lng, (rev) => {
        const pr = rev.properties || {};
        devRev2GeoPanel.hidden = false;

        const urlMasked = `https://api.geoapify.com/v1/geocode/reverse?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&apiKey=YOUR_API_KEY`;
        devRev2PinEl.innerHTML = `<strong>URL:</strong> ${urlMasked} | <strong>Formatted:</strong> ${pr.formatted || '—'}`;
        const propsSnippet = JSON.stringify(pr, null, 2);
        devRev2PinJsonEl.textContent = propsSnippet.length > 4000 ? propsSnippet.slice(0, 4000) + '\n…' : propsSnippet;
        lastRevFromDrag = pr;

        // update last address if last address too far away
        if (pr.distance <= MAX_LOCATION_TO_ADDRESS_ERROR) {
          lastAddress = pr;
          ac.setValue(pr.formatted);
        }

        updateConfirmState();
      }, 'pin');
    }

    function updateConfirmState() {
      const hasPin = !!marker;
      confirmBtn.disabled = !hasPin;
    }

    confirmBtn.addEventListener('click', () => {
      if (!lastLocation || !lastAddress) return;

      const lat = lastLocation.lat;
      const lng = lastLocation.lon;

      const addr = lastAddress.formatted;
      confirmMessage.textContent = addr ? `Saved with pin: ${lat.toFixed(6)}, ${lng.toFixed(6)} — Address: ${addr}` : `Saved with pin: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;

      // Developer summary of calls and state
      const summary = [];
      summary.push(`<strong>Address:</strong> ${addr}`);
      summary.push(`<strong>Location:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}`)
      const dist = haversineMeters(lastAddress.lat, lastAddress.lon, lat, lng);
      summary.push(`<strong>Distance address↔location:</strong> ${Math.round(dist)} m`);

      devSummaryPanel.hidden = false;
      devSummaryEl.innerHTML = summary.join(' | ');
      const json = {
        ipGeolocation: ipGeolocation,
        browserGeolocation: geolocation || null,
        autocompleteSearch: lastSearch || null,
        reverseFromGeolocation: lastRevFromGeo || null,
        reverseFromPin: lastRevFromDrag || null,
        final: { lat, lon: lng, addressText: addr }
      };
      const jsonText = JSON.stringify(json, null, 2);
      devSummaryJsonEl.textContent = jsonText.length > 8000 ? jsonText.slice(0, 8000) + '\n…' : jsonText;
    });

    // Utils
    function reverseGeocode(lat, lon, cb, target = 'pin') {
      const url = `https://api.geoapify.com/v1/geocode/reverse?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&apiKey=${myAPIKey}`;
      const masked = url.replace(/(apiKey=)[^&]+/i, '$1YOUR_API_KEY');

      if (target === 'pin') {
        devRev2PinEl.innerHTML = `<strong>URL:</strong> ${masked}`;
      } else if (target === 'geo') {
        devRev1GeoEl.innerHTML = `<strong>URL:</strong> ${masked}`;
      }
      fetch(url).then(r => r.json()).then(data => {
        const f = (data && data.features && data.features[0]) ? data.features[0] : null;
        if (!f) {
          if (target === 'pin')
            devRev2PinEl.innerHTML += ' | No reverse result';
          else
            devRev1GeoEl.innerHTML += ' | No reverse result';
          cb({ properties: {} }); return;
        }

        cb(f);
      }).catch(err => {
        if (target === 'pin')
          devRev2PinEl.innerHTML += ` | Error: ${String(err)}`;
        else
          devRev1GeoEl.innerHTML += ` | Error: ${String(err)}`;
        cb({ properties: {} });
      });
    }


    // Haversine distance in meters
    function haversineMeters(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180; const R = 6371000;
      const dLat = toRad(lat2 - lat1); const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }
  </script>
  <script>
    // Developer info visibility toggle (non-intrusive; does not change existing logic)
    (function(){
      const key = 'demo:showDevPanels';
      const cb = document.getElementById('dev-toggle');
      function apply(val){
        if (val) document.body.classList.remove('hide-dev');
        else document.body.classList.add('hide-dev');
      }
      if (cb) {
        const saved = localStorage.getItem(key);
        const show = saved === null ? true : saved === 'true';
        cb.checked = show;
        apply(show);
        cb.addEventListener('change', () => {
          const v = cb.checked;
          localStorage.setItem(key, String(v));
          apply(v);
        });
      }
    })();
  </script>
</body>

</html>
